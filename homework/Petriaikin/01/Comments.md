
# О программе

Файл программы - sum.cpp

Ключи командной строки:  
-r: суммировать по рядам  
-c: суммировать по столбцам

После работы программа записывает в файл (rows/columns)results.txt полученные значения после 100 итераций

# Анализ способа обхода оптимизации компилятора

При "простом" изменении порядка индексов в квадратных скобках компилятор MSVS в режиме -O2 проводит оптимизацию и генерирует код, суммирующий по строкам.

**Варианты обхода оптимизации:**
Мы хотим найти способ, который в наименьшей степени отразится на производительности. Для сравнения использовалось суммирование по строкам (для повторимости синтаксис суммирования по столбцам и по строкам должен быть одинаков). Все тесты - 10 разгонных суммирований, 100 итераций, 1 прогон. При использовании []: 32405.69 mcs
1. Использовать суммирование "с конца" (т.е. с последней строки/столбца) - не применялся, т.к. мы хотим изучить использование кэша при линейном проходе по массиву.
2. Вместо [] использовать арифметику указателей. Результат: 38929.08 mcs
3. Указать volatile спецификатор матице. Результат: 47422.86 mcs
4. Указать volatile спецификатор переменной result (записывает сумму). Результат: 221115.28 mcs

Таким образом, из всех способов избежать оптимизации цикла (на уровне -o2) лучшим является использование арифметики указателей

# Результаты
10 разгонных итераций, 100 итераций с подсчетом времени, 5 прогонов
Вариант программы с арифметикой указателей

* Cуммирование по строкам: 38492.01 mcs
* Суммирование по столбцам: 1288343.89 mcs

# Valgrind
Для анализа статистики использования кэш-памяти использовался Cachegrind из пакета Valgrind.  
3 разгонных итерации, 10 итераций с подсчетом времени (т.к. под valgrind долго исполняется)

* Суммирование по строкам:  
D   refs:       2,601,016,518  (1,300,739,833 rd   + 1,300,276,685 wr)  
D1  misses:       162,522,292  (   81,269,466 rd   +    81,252,826 wr)   
LL refs:          162,525,137  (   81,272,311 rd   +    81,252,826 wr)  


* Суммирование по столбцам:  
D   refs:       2,601,017,071  (1,300,740,212 rd   + 1,300,276,859 wr)  
D1  misses:     1,381,272,295  (1,300,019,469 rd   +    81,252,826 wr)  
LL refs:        1,381,275,148  (1,300,022,322 rd   +    81,252,826 wr)

# Выводы

1. При суммировании по столбцам программа чаще не находит данные в кэше 1го уровня и ей приходится обращатся в кэш более высокого уровня, что замедляет работу (в нашем случае - в 33.5 раза)
2. Использование ключевого слова volatile требует осторожности - оно замедляет работу программы, особенно, если применяется к переменным, к которым обращаются часто

