
# О программе

Файл программы - sum.cpp

Ключи командной строки:  
-r: суммировать по рядам  
-c: суммировать по столбцам

После работы программа записывает в файл (rows/columns)results.txt полученные значения после 100 итераций

# Анализ способа обхода оптимизации компилятора

При "простом" изменении порядка индексов в квадратных скобках компилятор MSVS в режиме -O2 проводит оптимизацию и генерирует код, суммирующий по строкам.

**Варианты обхода оптимизации:**
Мы хотим найти способ, который в наименьшей степени отразится на производительности. Для сравнения использовалось суммирование по строкам (для повторимости синтаксис суммирования по столбцам и по строкам должен быть одинаков). Все тесты - 10 разгонных суммирований, 100 итераций, 1 прогон. При использовании []: 31909.60 mcs
1. Использовать суммирование "с конца" (т.е. с последней строки/столбца) - не применялся, т.к. мы хотим изучить использование кэша при линейном проходе по массиву.
2. **(Признано недопустимым приемом в рамках задания)** Вместо [] использовать арифметику указателей. Результат: 38929.08 mcs
3. Указать volatile спецификатор матице. Результат: 47422.86 mcs
4. Указать volatile спецификатор переменной result (записывает сумму). Результат: 221115.28 mcs
5. **(Лучший, используется)** В начале внешнего цикла прибавлять rows, в конце его вычитать. Результат: 32893.04 mcs, т.е. практически не влияет на производительность

# Анализ способа создания функции суммирования с "двойным" функционалом
Избежать копирования циклов возможно двумя способами (это желательно, т.к. нужно будет всего один раз изменять логику суммирования при обходе оптимизации):
1. Использовать if в цикле суммирования (result += ((type == SummType::BY_ROWS) ? matrix [i][j] : matrix [j][i]);): 227510.37 mcs - очень долго
2. Использовать макроопределение с параметром

# Результаты
10 разгонных итераций, 100 итераций с подсчетом времени, 5 прогонов

* Cуммирование по строкам: 32657.77 mcs
* Суммирование по столбцам: 1335236.44 mcs

# Valgrind
Для анализа статистики использования кэш-памяти использовался Cachegrind из пакета Valgrind.  
3 разгонных итерации, 10 итераций с подсчетом времени (т.к. под valgrind долго исполняется)

* Суммирование по строкам:  
D  refs:       2,601,016,518  (1,300,739,833 rd   + 1,300,276,685 wr)  
D1 misses:       162,522,292  (   81,269,466 rd   +    81,252,826 wr)  
LL refs:         162,525,137  (   81,272,311 rd   +    81,252,826 wr)  


* Суммирование по столбцам:  
D  refs:       2,601,017,071  (1,300,740,212 rd   + 1,300,276,859 wr)  
D1 misses:     1,381,272,295  (1,300,019,469 rd   +    81,252,826 wr)  
LL refs:       1,381,275,148  (1,300,022,322 rd   +    81,252,826 wr)

# Выводы

1. При суммировании по столбцам программа чаще не находит данные в кэше 1го уровня и ей приходится обращатся в кэш более высокого уровня, что замедляет работу (в нашем случае - в 40.9 раз)
2. Использование ключевого слова volatile требует осторожности - оно замедляет работу программы, особенно, если применяется к переменным, к которым обращаются часто
3. Условные конструкции сильно замедляют циклы (в нашем случае - в 7 раз)

